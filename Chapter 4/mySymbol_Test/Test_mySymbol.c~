#include "../mySymbol.h"
#include <CUnit/CUnit.h>
#include <CUnit/Basic.h>
#include <assert.h>
#include <string.h>

/*-------------------------------------------------------------*/
/*	NOTE:
 *		To use following tests, uncomment following blocks,
 *	uncomment following prototpyes and remove 'static' keyword
 *	in mySymbol.c file.
 *		After test, re-write 'static' back.
 *
 *	Prototypes:
 *	mySymbol makeSymbol_(myString name, mySymbol next);
 *	int hashFunc_MySymbol(char* c);
 */


void makeSymbol__ShouldReturnNullOnInvalidParams(void)
{
  //	fixture setup and system under control
  mySymbol actual = (mySymbol)makeSymbol_((mySymbol)NULL, NULL);
  mySymbol expected = NULL;
  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	system under control
  actual = (mySymbol)makeSymbol_("", NULL);
  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	teardown (nothing)
}

void makeSymbol__ShouldReturnRightOnValidParams(void)
{
  //	fixture setup and system under control
  mySymbol actual = (mySymbol)makeSymbol_("symbol", NULL);
  
  //	verify
  CU_ASSERT_NOT_EQUAL(actual, NULL);
  CU_ASSERT_EQUAL(strcmp(actual->name, "symbol"), 0);
  CU_ASSERT_EQUAL(actual->next, NULL);

  //	teardown (nothing)
}

void hashFunc_MySymbol_ShouldReturnNullOnInvalidParams(void)
{
  //	fixture setup and test function (NULL param)
  int actual = hashFunc_MySymbol((char*)NULL);
  int expected = -1;

  //	verify
  CU_ASSERT_EQUAL(actual, -1)

  //	test function (null string)
  actual = hashFunc_MySymbol("");

  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	teardown 
  //	nothing to do
}

void hashFunc_MySymbol_ShouldNotReturnNullOnVaildParams(void)
{
  //	fixture setup, test, and verify
  CU_ASSERT_NOT_EQUAL(hashFunc_MySymbol("valid"), -1);
}

void MySymbol_MakeSymbol_ShouldReturnNullOnInvalidParam(void)
{
  //	fixture setup and function test (NULL param)
  mySymbol expected = NULL;
  mySymbol actual = MySymbol_MakeSymbol((myString)NULL);
  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	function test (null string)
  actual = MySymbol_MakeSymbol("");
  //	verify
  CU_ASSERT_EQUAL(actual, expected);
}

void MySymbol_MakeSymbol_ShouldMakeSymbolOnValidParam(void)
{
  //	fixture setup
  mySymbol actual;

  //	system under control (fisrt make)
  actual = MySymbol_MakeSymbol("str1");

  //	verify
  CU_ASSERT_EQUAL(strcmp(actual->name, "str1"), 0);
  CU_ASSERT_EQUAL(actual->next, NULL);
 
  //	system under control (second make with different str)
  actual = MySymbol_MakeSymbol("str2");
  //	verify
  CU_ASSERT_EQUAL(strcmp(actual->name, "str2"), 0);
  CU_ASSERT_EQUAL(strcmp(actual->next->name, "str1"), 0);

  //	teardown (NOTE:
  //	pointers can not be freed, or will cause an error of infinite loop in following tests
}

void MySymbol_MakeSymbol_ShouldNotMakeOnSameStringParam(void)
{
  //	fixture setup
  mySymbol actual, expected;

  //	guard condition
  expected = MySymbol_MakeSymbol("same");
  CU_ASSERT_NOT_EQUAL(expected, NULL);
  //	system under control (same input string)
  actual = MySymbol_MakeSymbol("same");
  
  //	verify
  CU_ASSERT_EQUAL(actual, expected);
}

void MySymbol_GetName_ShouldWorkRight(void)
{
  //	simple test
  mySymbol symbol = MySymbol_MakeSymbol("hot");
  CU_ASSERT_EQUAL(strcmp(MySymbol_GetName(symbol), "hot"), 0);
}

void MySymbol_MakeNewTable_ShoudReturnSymbolUnlessNoMemoryLeft(void)
{
  //    simple test
  CU_ASSERT_NOT_EQUAL(MySymbol_MakeNewTable(), NULL);
}

void MySymbol_Enter_ShouldReturnFalseOnInvalidParams(void)
{
  //	fixture setup
  bool actual, expected = false;
  myTable table = MySymbol_MakeNewTable();

  //	system under control (NULL table)
  actual = MySymbol_Enter((myTable)NULL, MySymbol_MakeSymbol("symbol"), "value");
  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	system under control (NULL symbol)
  actual = MySymbol_Enter(table, MySymbol_MakeSymbol(NULL), "value");
  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	system under control (intended "" symbol)
  actual = MySymbol_Enter(table, "", "value");
  //	verify
  CU_ASSERT_EQUAL(actual, expected);

  //	teardown (nothing)
}



/*-------------------------------------------------------------*/

int main (int argc, char *argv[])
{
  if (CU_initialize_registry() != CUE_SUCCESS)
  {
    printf("initialization error!\n");
    exit(-1);
  }

  CU_pSuite suite = CU_add_suite("only suite", NULL, NULL);
  if (suite == NULL)
  {
    printf("attempt to add suite, error!\n");
    exit(-1);
  }

  //	add test
  assert(CU_add_test(suite, "test func----makeSymbol_()", makeSymbol__ShouldReturnNullOnInvalidParams));
  assert(CU_add_test(suite, "test func----makeSymbol_()", makeSymbol__ShouldReturnRightOnValidParams));
  assert(CU_add_test(suite, "test func----hashFunc_MySymbol()", hashFunc_MySymbol_ShouldReturnNullOnInvalidParams));
  assert(CU_add_test(suite, "test func--hashFunc_MySymbol()", hashFunc_MySymbol_ShouldNotReturnNullOnVaildParams));
  assert(CU_add_test(suite, "test func----MySymbol_MakeSymbol()", MySymbol_MakeSymbol_ShouldReturnNullOnInvalidParam));
  assert(CU_add_test(suite, "test func----MySymbol_MakeSymbol()", MySymbol_MakeSymbol_ShouldMakeSymbolOnValidParam));
  assert(CU_add_test(suite, "test func----MySymbol_MakeSymbol()", MySymbol_MakeSymbol_ShouldNotMakeOnSameStringParam));
  assert(CU_add_test(suite, "test func----MySymbol_GetName()", MySymbol_GetName_ShouldWorkRight));
  assert(CU_add_test(suite, "test func----MySymbol_MakeNewTable()", MySymbol_MakeNewTable_ShoudReturnSymbolUnlessNoMemoryLeft));
  assert(CU_add_test(suite, "test func----MySymbol_Enter()", MySymbol_Enter_ShouldReturnFalseOnInvalidParams));

  if (CU_basic_run_suite(suite) != CUE_SUCCESS)
  {
    printf("attempt to run suite, error!\n");
    exit(-1);
  }

  CU_cleanup_registry();
  return 0;
}
